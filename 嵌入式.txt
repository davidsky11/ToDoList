linux下的嵌入式开发技能（嵌入式工程师必备）

嵌入式Linux开发从下到上分为：嵌入式硬件开发、嵌入式驱动开发、嵌入式系统开发、嵌入式软件开发。

一、嵌入式硬件开发：熟悉电路等知识，非常熟悉各种常用元器件，掌握模拟电路和数字电路设计的开发能力。熟练掌握嵌入式硬件知识，熟悉硬件开发模式和设计模式，熟悉ARM32位处理器嵌入式硬件平台开发、并具备产品开发经验。精通常用的硬件设计工具：Protel/PADS(PowerPCB)/Cadence/OrCad。一般需要有4~8层高速PCB设计经验。

二、嵌入式驱动开发：熟练掌握Linux操作系统、系统结构、计算机组成原理、数据结构相关知识。熟悉嵌入式ARM开发，至少掌握Linux字符驱动程序开发。具有单片机、ARM嵌入式处理器的移植开发能力，理解硬件原理图，能独立完成相关硬件驱动调试，具有扎实的硬件知识，能够根据芯片手册编写软件驱动程序。

三、嵌入式系统开发：掌握Linux系统配置，精通处理器体系结构、编程环境、指令集、寻址方式、调试、汇编和混合编程等方面的内容；掌握Linux文件系统制作，熟悉各种文件系统格式（YAFFS2、JAFFS2、RAMDISK等）；熟悉嵌入式Linux启动流程，熟悉Linux配置文件的修改；掌握内核裁减、内核移植、交叉编译、内核调试、启动程序Bootloader编写、根文件系统制作和集成部署Linux系统等整个流程；熟悉搭建Linux软件开发环境（库文件的交叉编译及环境配置等）。

四、嵌入式软件开发：精通Linux操作系统的概念和安装方法、Linux下的基本命令、管理配置和编辑器，包括VI编辑器，GCC编译器，GDB调试器和 Make 项目管理工具等知识；精通C语言的高级编程知识，包括函数与程序结构、指针、数组、常用算法、库函数的使用等知识、数据结构的基础内容，包括链表、队列等；掌握面向对象编程的基本思想，以及C++语言的基础内容；精通嵌入式Linux下的程序设计，精通嵌入式Linux开发环境，包括系统编程、文件I/O、多进程和多线程、网络编程、GUI图形界面编程、数据库；熟悉常用的图形库的编程，如QT、GTK、miniGUI、fltk、nano-x等。

Makefile	Kbuild	Kconfig	





ARM 与嵌入式 linux 入门的建议（深蓝科技原创）

由于很多人总问这个问题，所以这里做一个总结文档供大家参考。这里必须先说明，以下的步骤都是针对 Linux 系统的，并不面向 WinCE。也许你会注意到，现在做嵌入式的人中，做 linux 研究的人远比做 WinCE 的人多，很多产家提供的资料也是以 linux 为主。我一直很难理解，其实 WinCE 的界面比 linux 的界面好看多了，使用起来也很方便，更为重要的是，WinCE 的开发和 Windows 下的开发基本一样，学起来简单得多，但是学 linux 或者使用 linux 做嵌入式的人就是远比 WinCE 多。在和很多工作的人交流时我了解到，他们公司从没考虑使用 WinCE，因为成本高，都是使用 linux 进行开发。我读研究生的的实验室中也没有使用 WinCE 的，大都研究 linux，也有少部分项目使用 vxwork，但是就没有听说过使用 WinCE 的，原因就是开源!当然现在 WinCE6.0 听说也开源，不过在成本和资源上 linux 已经有了无人能挡的优势。与此相对应的是，越来越多的电子厂商已经开始使用 linux 开发产品。举个例子，Google 近期开发的智能手机操作系统 Android 其实就是使用 linux-2.6.23 内核进行改进得到的。 

        第一，学习基本的裸机编程。
对于学硬件的人而言，必须先对硬件的基本使用方法有感性的认识，更必须深刻认识该硬件的控制方式，如果一开始就学 linux 系统、学移植那么只会马上就陷入一个很深的漩涡。我在刚刚开始学 ARM 的时候是选择 ARM7(主意是当时 ARM9 还很贵)，学 ARM7 的时候还是保持着学 51 单片机的思维，使用 ADS 去编程，第一个实验就是控制 led。学过一段时间 arm 的人都会笑这样很笨，实际上也不是，我倒是觉得有这个过程会好很多，因为无论做多复杂的系统最终都会落实到这些最底层的硬件控制，因此对这些硬件的控制有了感性的认识就好很多了
学习裸机的编程的同时要好好理解这个硬件的构架、控制原理，这些我称他为理解硬件。所谓的理解硬件就是说，理解这个硬件是怎么组织这么多资源的，这些资源又是怎么由 cpu、由编程进行控制的。比如说，s3c2410 中有 AD 转换器，有 GPIO(通用 IO 口)，还有 nandflash 控制器，这些东西都有一些寄存器来控制，这些寄存器都有一个地址，那么这些地址是什么意思?又怎么通过寄存器来控制这些外围设备的运转?还有，norflash 内部的每一个单元在这个芯片的内存中都有一个相应的地址单元，那么这些地址与刚刚说的寄存器地址又有什么关系?他们是一样的吗?而与 norflash 相对应的 nandflash 内部的储存单元并不是线性排放的，那么 s3c2410 怎么将 nandflash 的地址映射在内存空间上进行使用?或者简单地说应该怎么用 nandflash?再有，使用 ADS 进对 arm9 行编程时都需要使用到一个初始化的汇编文件，这个文件究竟有什么用?他里面的代码是什么意思?不要这个可以吗?
诸如此类都是对硬件的理解，理解了这些东西就对硬件有很深的理解了，这对以后更深一步的学习将有很大的帮助，如果跳过这一步，我相信越往后学越会觉得迷茫，越觉得这写东西深不可测。因为，你的根基没打好。
不过先声明一下，本人并没有使用 ADS 对 ARM9 进行编程，我是学完 ARM7 后直接就使用 ARM9 学 linux 系统的，因此涉及使用 ADS 对 arm9 进行编程的问题我很难回答^_^，自己去研究研究吧。
对于这部分不久将提供一份教程，这个教程中的例程并不是我为我们所代理的板子写的，是我在我们学院实验室拿的，英培特为他们自己 的实验箱写的，不过很有借鉴意义，可以作为一份有价值的参考。

        第二，使用 linux 系统进行一些基本的实验。
在买一套板子的时候一般会提供一些 linux 的试验例程，好好做一段时间这个吧，这个过程也是很有意义的，也是为进一步的学习积累感性认识，你能想象一个从没有使用过 linux 系统的人能学好 linux 的编程吗?好好按照手册上的例程做一做里面的实验，虽然有点娃娃学走路，有点弱智，但是我想很多高手都会经历这个过程。
在这方面我们深蓝科技目前没有计划提供相应的例程，主要是开发板的提供商会提供很丰富的例程，我们不做重复工作，只提供他们没有的、最有价值的东西给大家。

        第三，研究完整的 linux 系统的的运行过程。
所谓完整的 linux 系统包括哪些部分呢?
三部分：bootloader、linux kernel(linux 内核)、rootfile(根文件系统)。
那么这 3 部分是怎么相互协作来构成这个系统的呢?各自有什么用呢?三者有什么联系?怎么联系?系统的执行流程又是怎么样的呢?搞清楚这个问题你对整个系统的运行就很清楚了，对于下一步制作这个 linux 系统就打下了另一个重要的根基。介绍这方面的资料网上可以挖掘到几吨，自己好好研究吧。

        第四，开始做系统移植。 
上面说到完整的 linux 有 3 部分，而且你也知道了他们之间的关系和作用，那么现在你要做的便是自己动手学会制作这些东西。
当然我不可能叫你编写这些代码，这不实现。事实上这个 3 者都能在网下载到相应的源代码，但是这个源代码不可能下载编译后就能在你的系统上运行，需要很多的修改，直到他能运行在你的板子上，这个修改的过程就叫移植。在进行移植的过程中你要学的东西很多，要懂的相关知识也很多，等你完成了这个过程你会发现你已经算是一个初出茅庐的高手了。
在这个过程中如果你很有研究精神的话你必然会想到看源代码。很多书介绍你怎么阅读 linux 源代码，我不提倡无目的地去看 linux 源代码，用许三多的话说，这没有意义。等你在做移植的时候你觉得你必须去看源代码时再去找几本好书看看，这里我推荐一本好书倪继利的《linux 内核的分析与编程》，这是一本针对 linux-2.6.11 内核的书，说得很深，建议先提高自己的 C 语言编程水平再去看。
至于每个部分的移植网上也可以找到好多吨的资料，自己研究研究吧，不过要提醒的是，很多介绍自己经验的东西都或多或少有所保留，你按照他说的去做总有一些问题，但是他不会告诉你怎么解决，这时就要靠自己，如果自己都靠不住就找我一起研究研究吧，我也不能保证能解决你的问题，因为我未必遇到过你的问题，不过我相信能给你一点建议，也许有助你解决问题。
这一步的最终目的是，从源代码的官方主页上(都是外国的，悲哀)下载标准的源代码包，然后进行修改，最终运行在板子上。
盗用阿基米德的一句话：“给我一根网线，我能将 linux 搞定”。

        第五，研究 linux 驱动程序的编写。
移植系统并不是最终的目的，最终的目的是开发产品，做项目，这些都要进行驱动程序的开发。
Linux 的驱动程序可以说是五花八门，linux2.4 和 linux2.6 的编写有相当大的区别，就是同为 linux2.6 但是不同版本间的驱动程序也有区别，因此编写 linux 的驱动程序变都不是那么容易的事情，对于最新版本的驱动程序的编写甚至还没有足够的参考资料。那么我的建议就是使用、移植一个不算很新的版本内核，这样到时学驱动的编程就有足够的资料了。
这部分的推荐书籍可以参考另一篇文章《推荐几本学习嵌入式 linux 的书籍》。

        第六，研究应用程序的编写。
做作品做项目除了编写驱动程序，最后还要编写应用程序。现在的趋势是图形应用程序的开发，而图形应用程序中用得最多的还是 qt/e 函数库。我一直就使用这个函数库来开发自己的应用程序，不过我希望你能使用国产的 MiniGUI 函数库。盗用周杰伦的广告词就是“支持国产，支持 MiniGUI”。MiniGUI 的编程比较相似 Windows 下的 VC 编程，比较容易上手，效果应该说是相当不错的，我曾使用过来开发 arm7 的程序。不过 MiniGUI 最大的不好就是没有像 qtopia 这样的图形操作平台，这大大限制了他的推广，我曾经幻想过与北京飞漫公司(就是 MiniGUI 的版权拥有者)合作使用 MiniGUI 函数库开发像 qtopia 这样的图形操作平台，不过由于水平有限这只能是幻想了，呵呵。
完成这一步你基本就学完了嵌入式 linux 的全部内容了。
还有一个小小的经验想和大家分享。我在学习嵌入式 linux 的过程中很少问人，客观原因是身边的老师、同学师兄都没有这方面的高手，主观原因是我不喜欢问人，喜欢自己研究解决问题。这样做有个好处，就是可以提高自己解决问题的能力，因为做这些东西总有很多问题你难以理解，别人也没有这方面的经验，也不是所有问题都有人给你答案，这时必须要自己解决问题，这样，个人的解决问题能力就显得非常关键了。因此我的建议就是一般的问题到网上搜索一下，确实找不到答案了就问问高手，还是不行了就自己去研究，不要一味去等别人帮你解决问题。
记住，问题是学习的最好机会。







嵌入式系统Linux内核开发工程师必须掌握的三十个点

1)      Linux中主要有哪几种内核锁？

2)      Linux中的用户模式和内核模式是什么含意？

3)      怎样申请大块内核内存？

4)      用户进程间通信主要哪几种方式？

5)      通过伙伴系统申请内核内存的函数有哪些？

6)      通过slab分配器申请内核内存的函数有？

7)      Linux的内核空间和用户空间是如何划分的（以32位系统为例）？

8)      vmalloc()申请的内存有什么特点？

9)      用户程序使用malloc()申请到的内存空间在什么范围？

10)     在支持并使能MMU的系统中，Linux内核和用户程序分别运行在物理地址模式还是虚拟地址模式？

11)     ARM处理器是通过几级页表进行存储空间映射的？

12)     Linux是通过什么组件来实现支持多种文件系统的？

13)     Linux虚拟文件系统的关键数据结构有哪些？（至少写出四个）

14)     对文件或设备的操作函数保存在那个数据结构中？

15)     Linux中的文件包括哪些？

16)     创建进程的系统调用有那些？

17)     调用schedule()进行进程切换的方式有几种？

18)     Linux调度程序是根据进程的动态优先级还是静态优先级来调度进程的？

19)     进程调度的核心数据结构是哪个？

20)     如何加载、卸载一个模块？

21)     模块和应用程序分别运行在什么空间？

22)     Linux中的浮点运算由应用程序实现还是内核实现？

23)     模块程序能否使用可链接的库函数？

24)     TLB中缓存的是什么内容？

25)     Linux中有哪几种设备？

26)     字符设备驱动程序的关键数据结构是哪个？

27)     设备驱动程序包括哪些功能函数？

28)     如何唯一标识一个设备？

29)     Linux通过什么方式实现系统调用？

30)     Linux软中断和工作队列的作用是什么？











###################################################################################

1)      Linux中主要有哪几种内核锁？

	# 自旋锁、信号量
	# Linux内核中的同步机制：原子操作、信号量、读写信号量和自旋锁的API，另外一些同步机制，包括大内核锁、读写锁、大读者锁、RCU(Read-Copy Update，读-拷贝修改)和顺序锁。
	# 内核模式的代码可以无限制地访问所有处理器指令集以及全部内存和I/O空间。如果用户模式的进程要享有此特权，它必须通过系统调用向设备驱动程序或其他内核模式的代码发出请求。另外，用户模式的代码允许发送缺页，而内核模式的代码不允许。

2)      Linux中的用户模式和内核模式是什么含意？

	# 在Linux机器上，CPU要麽处于受信任的内核模式，要麽处于受限制的用户模式。除了内核本身处于内核模式以外，所有的用户都运行在用户模式之中。

3)      怎样申请大块内核内存？

	# 在Linux内核环境下，申请大块内存的成功率随着系统运行时间的增加而减少，虽然可以通过vmalloc系统调用申请物理不连续但虚拟地址连续的内存，但毕竟其使用效率不高且在32位系统上vmalloc的内存地址空间有限。所以，一般的建议是在系统启动阶段申请大块内存，但是其成功的概率也只是比较高而已，而不是100%。

4)      用户进程间通信主要哪几种方式？

	# 管道(Pipe)、命名管道(named pipe)、信号(Signal)、消息(Message)、共享内存、信号量(semaphore)、套接字(Socket)。

5)      通过伙伴系统申请内核内存的函数有哪些？

	# 在物理页面管理上实现了基于区的伙伴系统（zone base buddy system）。对于不同区的内存使用单独的伙伴系统管理，而且独立地监控空闲页。相应的接口alloc_pages(gfp_mask, order), __get_free_pages(gfp_mask, order)等。

6)      通过slab分配器申请内核内存的函数有？

	struct kmem_cache* kmem_cache_create(const char *name, size_t size, size_t align, unsigned long flags, void (*ctor)(void*))	该函数创建一个新的高速缓存

	void *kmem_cache_alloc(struct kmem_cache* cachep,gfp_t flags)	该函数从给定的高速缓存cachep中返回一个指向对象的指针。

	int kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)	该函数从给定的高速缓存cachep中返回一个指向对象的指针。

7)      Linux的内核空间和用户空间是如何划分的（以32位系统为例）？

	# 进程寻址空间0~4G，进程通过系统调用进入内核态

	# 通常32位Linux内核地址空间划分为0~3G为用户空间，3~4G为内核空间。
	# 32位系统用户进程最大可以访问3G内存，内核代码可以访问所有物理内存；
	  64位系统用户进程最大可以访问512G内存，内核代码可以访问所有物理内存。

8)      kmalloc和vmalloc()申请的内存有什么特点？

	##
	1. kmalloc和vmalloc是分配的是内核的内存地址；
	2. kmalloc保证分配的内存在物理上是连续的，当然在虚拟地址空间上也是连续的；
	3. vmalloc保证的是在虚拟地址空间上的连续，vmalloc()则是位于物理地址非连续，虚地址连续区，起始位置由VMALLOC_START来决定，一般作为交换区、模块的分配。

9)      用户程序使用malloc()申请到的内存空间在什么范围？

	# Linux下虚拟地址空间分给进程本身的是3G，那么一般程序使用malloc()申请到的内存空间最多3G，但是一般情况下是达不到的。

10)     在支持并使能MMU的系统中，Linux内核和用户程序分别运行在物理地址模式还是虚拟地址模式？

	# Linux内核程序运行在物理地址模式，Linux用户程序运行在虚拟地址模式。

11)     ARM处理器是通过几级页表进行存储空间映射的？

12)     Linux是通过什么组件来实现支持多种文件系统的？
	
	# VFS + VFS interface

13)     Linux虚拟文件系统的关键数据结构有哪些？（至少写出四个）

	# file_system_type / super_block / inode / file / dentry / vfsmount

14)     对文件或设备的操作函数保存在那个数据结构中？
	
	# file_operations

15)     Linux中的文件包括哪些？

	执行文件、普通文件、目录文件、链接文件、设备文件、管道文件

	# 有四种基本文件类型：普通文件、目录文件、链接文件和特殊文件。用file命令来识别。
	# 普通文件：如文本文件、C语言源码、shell脚本等，可用cat/less/more/vi等命令来查看内容，用mv改名。
	# 目录文件：包括文件名、子目录名及其指针。可用ls列出目录文件。
	# 链接文件：指向一个索引节点的哪些目录条目，用ls查看，链接文件的标志用l开头，而文件后以“->”指向所链接的文件。
	# 特殊文件：如磁盘、终端、打印机等都在文件系统中表示出来，常放在/etc目录中。

16)     创建进程的系统调用有那些？

	# clone() / fork() / vfork() / 
	系统调用哪个服务例程： sys_clone / sys_fork / sys_vfork

17)     调用schedule()进行进程切换的方式有几种？

	# 系统调用 do_fork()
	  定时中断 do_timer()
	  唤醒进程 wake_up_process()
	  改变进程的调度策略 setscheduler()
	  系统调用礼让 sys_sched_yield()

18)     Linux调度程序是根据进程的动态优先级还是静态优先级来调度进程的？

	# Linux调度程序是根据进程的动态优先级来调度进程的，但是动态优先级又是根据静态优先级根据算法计算出来的，两者是两个相关联的值。因为高优先级的进程总是比低优先级的进程先被调度，为防止多个高优先级的进程占用CPU资源，导致其他进程不能占用CPU，所以引用动态优先级概念。

19)     进程调度的核心数据结构是哪个？

	# runqueue

20)     如何加载、卸载一个模块？

	# 加载模块： sudo insmod **.ko / sudo dmesg |tail -n 1
	# 卸载模块： sudo rmmod ** / sudo dmesg | tail -n 1
	# 查看模块： lsmod |grep **

21)     模块和应用程序分别运行在什么空间？

	# 一个模块在内核空间运行，而应用程序在用户空间运行。

22)     Linux中的浮点运算由应用程序实现还是内核实现？

	# 应用程序实现，Linux中的浮点运算是利用数学库函数实现的，库函数能够被应用程序链接后调用，不能被内核链接调用。这些运算是在应用程序中运行的，然后再把结果反馈给系统。

23)     模块程序能否使用可链接的库函数？

	# 模块程序运行在内核空间，不能链接库函数。

24)     TLB中缓存的是什么内容？

	# TLB，页表缓存，当线性地址被第一次转换成物理地址的时候，将线性地址和物理地址的对应放在TLBB中，用于下次访问这个线性地址时，加快转换速度。

25)     Linux中有哪几种设备？

	# 字符设备、块设备、网络接口

26)     字符设备驱动程序的关键数据结构是哪个？

	字符设备描述符struct cdev, cdev_alloc() 用于动态的分配cdev 描述符，cdev_add() 用于注册一个cdev 描述符，cdev 包含一个struct kobject类型的数据结构，它是核心的数据结构。

	# cdev：	 代表一个字符设备驱动(char device, cdev)，每个字符设备驱动都有一个struct cdev 结构体变量与之对应，记录该设备驱动的相关信息，主要包括设备号dev_t dev 和设备操作函数集const struct file_operations *ops。
		struct cdev {
			struct kobject kobj;
			struct module *owner;
			const struct file_operations;
			struct list_head list;
			dev_t dev;
			unsigned int count;
		};

	# file_operations：	定义了设备驱动程序与用来访问内核之间的接口，该结构体定义的函数指来访问实际的硬件设备，不同的硬件设备具有不同的读写函数。

		struct file_operations {  
    			struct module *owner;  
    			loff_t (*llseek) (struct file *, loff_t, int);  
    			ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);  
    			ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);  
    			ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);  
    			ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);  
    			int (*readdir) (struct file *, void *, filldir_t);  
    			unsigned int (*poll) (struct file *, struct poll_table_struct *);  
    			long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);  
    			long (*compat_ioctl) (struct file *, unsigned int, unsigned long);  
    			int (*mmap) (struct file *, struct vm_area_struct *);  
    			int (*open) (struct inode *, struct file *);  
    			int (*flush) (struct file *, fl_owner_t id);  
    			int (*release) (struct inode *, struct file *);  
    			int (*fsync) (struct file *, int datasync);  
    			int (*aio_fsync) (struct kiocb *, int datasync);  
    			int (*fasync) (int, struct file *, int);  
    			int (*lock) (struct file *, int, struct file_lock *);  
    			ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);  
    			unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);  
    			int (*check_flags)(int);  
    			int (*flock) (struct file *, int, struct file_lock *);  
    			ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);  
    			ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);  
    			int (*setlease)(struct file *, long, struct file_lock **);  
		}; 
	
	# inode：表示一个文件节点，记录一个文件固有的通用信息，任何一个文件都有这个结构体变量。

	# file：表示一个已经打开的文件，记录打开文件的属性，包括读写属性，linux中一切皆文件，但是文件一般分为磁盘文件和特殊文件（设备文件）

27)     设备驱动程序包括哪些功能函数？

	# 设备驱动有： open() / read() / write() / llseek() / release()

28)     如何唯一标识一个设备？

	# 在设备管理中，除了设备类型外，内核还需要一对被称为主从设备号的参数，才能唯一标识一个设备。

	# 主设备号： 用于标识驱动程序，相同的主设备号使用相同的驱动程序。
	  从设备号： 用于标识同一驱动程序的不同硬件。

	# 在内核中用dev_t 来表示设备编号，一般它是32位 长度，其中12位用于表示主设备号，20位用于表示次设备号，利用MKDEV(int major, int minor)生成一个dev_t类型的对象。

29)     Linux通过什么方式实现系统调用？

	靠软件中断实现

	# Linux中实现系统调用利用了0x86体系结构中的软件中断。软件中断和我们常说的中断（硬件中断）不同之处在于，它是通过软件指令触发而并非外设引发的中断，也就是说，是编程人员开发出的一种异常（正常的异常），具体的讲就是调用int$0x80汇编指令，这条汇编指令将产生向量为0x80的编程异常。

	之所以系统调用需要借助异常来实现，是因为当用户态的进程调用一个系统调用时，CPU便被切换到内核态执行内核函数，而我们在i386体系结构部分已经知道了 进入内核 -- 进入高特权级别 -- 必须经过系统的 门机制，这里个异常实际上就是通过系统门陷入内核（除了int 0x80外用户空间还可以通过int3 -- 向量3、into -- 向量4、bound -- 向量5等异常指令进入内核，而其他异常无法被用户空间程序利用，都是有系统使用的）。

	更详细地解释一下这个过程。int $0x80指令的目的是产生一个编号为0x80的编程异常，这个编程异常对应的是中断描述符表IDT中的第128项 -- 也就是对应的系统门描述符。门描述符中含有一个预设的内核空间地址，它指向了系统调用处理程序：system_call()（不要和系统调用混淆，这个程序在entry.S文件中用汇编语言编写）。

	很显然，所有的系统调用都会统一地转到这个地址，但Linux一共有两三百个系统调用都从这里进入内核后有该如何派发到它们各自的服务程序去呢？解决这个问题的方法非常简单：首先，Linux为每个系统调用都进行了编号（0~NR_syscll），同时在内核中保存一张系统调用表，该表中保存了系统调用编号和其对应的服务例程，因此在系统调用通过系统门陷入内核前，需要把系统调用号一并传入内核，在x86上，这个传递动作是通过在执行int0x80 前把调用号装入eax 寄存器实现的。这样，系统调用处理程序一旦运行，就可以从eax 中得到数据，然后再区系统调用表中寻找相应服务例程了。

	除了需要传递系统调用号外，许多系统调用还需要传递一些参数到内核，比如sys_write(unsigned int fd, const char *buf, size_t count) 调用就需要传递文件描述符fd、要写入的内容buf 以及写入字节数count 等几个内容到内核。碰到这种情况，Linux会有6个寄存器可被用来传递这些参数：eax（存放系统调用号）、ebx、ecx、edx、esi及edi来存放这些额外的参数。具体做法是在system_call() 中使用SAVE_ALL 宏把这些寄存器的值保存在内核态堆栈中。

	备注：
	系统调用其实很简单，就是所有操作系统的API都是通过软件的中断动态的调用，通过调用int $0x80 触发软件中断，然后通过一些寄存器将参数传入，实现对操作系统API的调用。
	在嵌入式操作系统中有软中断的概念，该软中断是指将硬中断中次优先级的任务交给软中断处理，其运行与系统栈中，优先级高于任务，和这里说的软件中断有很大区别，软件中断处理和硬中断处理流程相同，只是该中断由软件触发。

30)     Linux软中断和工作队列的作用是什么？

	# Linux中的软中断和工作队列是中断处理。

	1、 软中断一般是“可延迟函数”的总称，它不能睡眠，不能阻塞，它处于中断上下文，不能进程切换，软中断不能被自己打断，只能被硬件中断打断（上半部），可以并发的运行在多个CPU上。所以软中断必须设计成可重入的函数，因此也需要自旋锁来保护其数据结构。

	2、 工作队列中的函数处在进程上下文中，它可以睡眠，也能阻塞，能够在不同的进程间切换，以完成不同的工作。可延迟函数和工作队列都不能访问用户的进程空间，可延时函数在执行时不可能有任何正在运行的进程，工作队列的函数在内核进程执行，，它不能访问用户空间地址。





##################  拓展  #####################

1、内核模块与应用程序的对比

		用户态程序		内核模块
	运行	用户空间			内核空间
	入口	main()			module_init()指定
	出口	无			module_exit()指定
	编译	gcc-c			Makefile
	连接	ld			insmod
	运行	直接运行			insmod
	调试	gdb			kdbug/kdb/kgdb等

    调用函数对比：
	程序员并不总是自己写所有用到的函数。一个常见的例子就是printf()，使用这些C标准库，libc提供的库函数。这些函数实际上在连接之前并不进入你的程序。在连接时这些函数调用才会指向你调用的库，从而使你的代码最终可以执行。
	内核模块有所不同。在模块中使用函数printk()没有包含标准I/O库。这是因为模块是在insmod加载时才连接的目标文件。那些要用到的函数的符号链接是内核自己提供的。也就是说，你可以在内核模块中使用的函数只能来自内核本身。如果你对内核提供了哪些函数符号链接感兴趣，可以看看文件/proc/kallsyms。

    库函数和系统调用的区别：
	库函数是高层的，完全运行在用户空间，为程序员提供调用更方便的接口，而真正在幕后完成实际事务的是系统调用。系统调用在内核态运行并且由内核自己提供。标志C库函数printf()可以被看做是一个通用的输出语句，但它实际做的是将数据转化为符合格式的字符串并且调用系统调用write()输出这些字符串。（可以用调试工具strace命令，它可以接管被跟踪进程执行的系统调用和收到的信号，然后把每一个执行的系统调用的名字，参数和返回值打印出来。）
	一般库函数在用户态执行。库函数调用一个或几个系统调用，而这些系统调用为库函数完成工作。

    内存对比：
	用户编程：使用malloc()和free()函数申请和释放内存
	内核模块：进行内核编程时，最常用的内存申请和释放函数为在include/linux/kernel.h文件中声明的kmalloc()和kfree()，其原型为：
		void *kmalloc(unsigned int len, int priority);
		void kfree(void *ptr);
	参数说明：
		kmalloc的priority参数通常设置为GFP_KERNEL，如果在中断服务程序里申请内存则用GFP_ATPMIC参数，因为使用GFP_KERNEL参数可能会引起睡眠，不能用于非进程上下文中（在中断中是不允许睡眠的）。
	说明：
		由于内核态和用户态使用不同的内存定义，所以二者之间不能直接访问对方的内存。而应该使用Linux中的用户态和内核态内存交互函数（在include/asm/uaccess.h中被声明）：
		unsigned long copy_from_user(void *to, const void *from, unsigned long n);
		unsigned long copy_to_user(void *to, void *from, unsigned long len);
		copy_from_user copy_to_user函数返回不能被复制的字节数，因此，如果完全复制成功，返回值为0。
		include/asm/uaccess.h中定义的put_user和get_user用于内核空间和用户空间的单值交互（如char、int、long）。

	其他：
		一种内核模块是设备驱动程序，为使用硬件设备而编写。在Unix中，任何设备都被当作路径/dev的设备文件处理，并通过这些设备文件提供访问硬件的方法。设备驱动为用户程序访问硬件设备。
		在Linux中，设备大致可分为：字符设备，块设备和网络接口。

		字符设备，包括那些必须以顺序方式，像字节流一样被访问的设备，如字符终端，串口等；
		块设备，是指那些可以用随机方式，以整块数据为单位来访问的设备，如硬盘等；
		网络接口，就指通常网卡和协议栈等复杂的网络输入输出服务。






























嵌入式程序员应该知道的十六个问题

1	预处理器（Preprocessor）
2	如何定义宏
3	预处理器标识#error的目的是什么
4	死循环（Infinite loops）
5	数据声明（Data declarations）
6	关键字static的作用是什么
7	关键字const有什么含义
8	Volatile的使用
9	位操作（Bit manipulation）
10	访问固定的内存位置（Accessing fixed memory locations）
11	中断（Interrupts）
12	符号扩展的代码例子
13	处理器字长导致的数据扩展问题
14	动态内存分配（Dynamic memory allocation）
15	用Typedef构造复合类型
16	晦涩的语法及代码风格