linux下的嵌入式开发技能（嵌入式工程师必备）

嵌入式Linux开发从下到上分为：嵌入式硬件开发、嵌入式驱动开发、嵌入式系统开发、嵌入式软件开发。

一、嵌入式硬件开发：熟悉电路等知识，非常熟悉各种常用元器件，掌握模拟电路和数字电路设计的开发能力。熟练掌握嵌入式硬件知识，熟悉硬件开发模式和设计模式，熟悉ARM32位处理器嵌入式硬件平台开发、并具备产品开发经验。精通常用的硬件设计工具：Protel/PADS(PowerPCB)/Cadence/OrCad。一般需要有4~8层高速PCB设计经验。

二、嵌入式驱动开发：熟练掌握Linux操作系统、系统结构、计算机组成原理、数据结构相关知识。熟悉嵌入式ARM开发，至少掌握Linux字符驱动程序开发。具有单片机、ARM嵌入式处理器的移植开发能力，理解硬件原理图，能独立完成相关硬件驱动调试，具有扎实的硬件知识，能够根据芯片手册编写软件驱动程序。

三、嵌入式系统开发：掌握Linux系统配置，精通处理器体系结构、编程环境、指令集、寻址方式、调试、汇编和混合编程等方面的内容；掌握Linux文件系统制作，熟悉各种文件系统格式（YAFFS2、JAFFS2、RAMDISK等）；熟悉嵌入式Linux启动流程，熟悉Linux配置文件的修改；掌握内核裁减、内核移植、交叉编译、内核调试、启动程序Bootloader编写、根文件系统制作和集成部署Linux系统等整个流程；熟悉搭建Linux软件开发环境（库文件的交叉编译及环境配置等）。

四、嵌入式软件开发：精通Linux操作系统的概念和安装方法、Linux下的基本命令、管理配置和编辑器，包括VI编辑器，GCC编译器，GDB调试器和 Make 项目管理工具等知识；精通C语言的高级编程知识，包括函数与程序结构、指针、数组、常用算法、库函数的使用等知识、数据结构的基础内容，包括链表、队列等；掌握面向对象编程的基本思想，以及C++语言的基础内容；精通嵌入式Linux下的程序设计，精通嵌入式Linux开发环境，包括系统编程、文件I/O、多进程和多线程、网络编程、GUI图形界面编程、数据库；熟悉常用的图形库的编程，如QT、GTK、miniGUI、fltk、nano-x等。

Makefile	Kbuild	Kconfig	





ARM 与嵌入式 linux 入门的建议（深蓝科技原创）

由于很多人总问这个问题，所以这里做一个总结文档供大家参考。这里必须先说明，以下的步骤都是针对 Linux 系统的，并不面向 WinCE。也许你会注意到，现在做嵌入式的人中，做 linux 研究的人远比做 WinCE 的人多，很多产家提供的资料也是以 linux 为主。我一直很难理解，其实 WinCE 的界面比 linux 的界面好看多了，使用起来也很方便，更为重要的是，WinCE 的开发和 Windows 下的开发基本一样，学起来简单得多，但是学 linux 或者使用 linux 做嵌入式的人就是远比 WinCE 多。在和很多工作的人交流时我了解到，他们公司从没考虑使用 WinCE，因为成本高，都是使用 linux 进行开发。我读研究生的的实验室中也没有使用 WinCE 的，大都研究 linux，也有少部分项目使用 vxwork，但是就没有听说过使用 WinCE 的，原因就是开源!当然现在 WinCE6.0 听说也开源，不过在成本和资源上 linux 已经有了无人能挡的优势。与此相对应的是，越来越多的电子厂商已经开始使用 linux 开发产品。举个例子，Google 近期开发的智能手机操作系统 Android 其实就是使用 linux-2.6.23 内核进行改进得到的。 

        第一，学习基本的裸机编程。
对于学硬件的人而言，必须先对硬件的基本使用方法有感性的认识，更必须深刻认识该硬件的控制方式，如果一开始就学 linux 系统、学移植那么只会马上就陷入一个很深的漩涡。我在刚刚开始学 ARM 的时候是选择 ARM7(主意是当时 ARM9 还很贵)，学 ARM7 的时候还是保持着学 51 单片机的思维，使用 ADS 去编程，第一个实验就是控制 led。学过一段时间 arm 的人都会笑这样很笨，实际上也不是，我倒是觉得有这个过程会好很多，因为无论做多复杂的系统最终都会落实到这些最底层的硬件控制，因此对这些硬件的控制有了感性的认识就好很多了
学习裸机的编程的同时要好好理解这个硬件的构架、控制原理，这些我称他为理解硬件。所谓的理解硬件就是说，理解这个硬件是怎么组织这么多资源的，这些资源又是怎么由 cpu、由编程进行控制的。比如说，s3c2410 中有 AD 转换器，有 GPIO(通用 IO 口)，还有 nandflash 控制器，这些东西都有一些寄存器来控制，这些寄存器都有一个地址，那么这些地址是什么意思?又怎么通过寄存器来控制这些外围设备的运转?还有，norflash 内部的每一个单元在这个芯片的内存中都有一个相应的地址单元，那么这些地址与刚刚说的寄存器地址又有什么关系?他们是一样的吗?而与 norflash 相对应的 nandflash 内部的储存单元并不是线性排放的，那么 s3c2410 怎么将 nandflash 的地址映射在内存空间上进行使用?或者简单地说应该怎么用 nandflash?再有，使用 ADS 进对 arm9 行编程时都需要使用到一个初始化的汇编文件，这个文件究竟有什么用?他里面的代码是什么意思?不要这个可以吗?
诸如此类都是对硬件的理解，理解了这些东西就对硬件有很深的理解了，这对以后更深一步的学习将有很大的帮助，如果跳过这一步，我相信越往后学越会觉得迷茫，越觉得这写东西深不可测。因为，你的根基没打好。
不过先声明一下，本人并没有使用 ADS 对 ARM9 进行编程，我是学完 ARM7 后直接就使用 ARM9 学 linux 系统的，因此涉及使用 ADS 对 arm9 进行编程的问题我很难回答^_^，自己去研究研究吧。
对于这部分不久将提供一份教程，这个教程中的例程并不是我为我们所代理的板子写的，是我在我们学院实验室拿的，英培特为他们自己 的实验箱写的，不过很有借鉴意义，可以作为一份有价值的参考。

        第二，使用 linux 系统进行一些基本的实验。
在买一套板子的时候一般会提供一些 linux 的试验例程，好好做一段时间这个吧，这个过程也是很有意义的，也是为进一步的学习积累感性认识，你能想象一个从没有使用过 linux 系统的人能学好 linux 的编程吗?好好按照手册上的例程做一做里面的实验，虽然有点娃娃学走路，有点弱智，但是我想很多高手都会经历这个过程。
在这方面我们深蓝科技目前没有计划提供相应的例程，主要是开发板的提供商会提供很丰富的例程，我们不做重复工作，只提供他们没有的、最有价值的东西给大家。

        第三，研究完整的 linux 系统的的运行过程。
所谓完整的 linux 系统包括哪些部分呢?
三部分：bootloader、linux kernel(linux 内核)、rootfile(根文件系统)。
那么这 3 部分是怎么相互协作来构成这个系统的呢?各自有什么用呢?三者有什么联系?怎么联系?系统的执行流程又是怎么样的呢?搞清楚这个问题你对整个系统的运行就很清楚了，对于下一步制作这个 linux 系统就打下了另一个重要的根基。介绍这方面的资料网上可以挖掘到几吨，自己好好研究吧。

        第四，开始做系统移植。 
上面说到完整的 linux 有 3 部分，而且你也知道了他们之间的关系和作用，那么现在你要做的便是自己动手学会制作这些东西。
当然我不可能叫你编写这些代码，这不实现。事实上这个 3 者都能在网下载到相应的源代码，但是这个源代码不可能下载编译后就能在你的系统上运行，需要很多的修改，直到他能运行在你的板子上，这个修改的过程就叫移植。在进行移植的过程中你要学的东西很多，要懂的相关知识也很多，等你完成了这个过程你会发现你已经算是一个初出茅庐的高手了。
在这个过程中如果你很有研究精神的话你必然会想到看源代码。很多书介绍你怎么阅读 linux 源代码，我不提倡无目的地去看 linux 源代码，用许三多的话说，这没有意义。等你在做移植的时候你觉得你必须去看源代码时再去找几本好书看看，这里我推荐一本好书倪继利的《linux 内核的分析与编程》，这是一本针对 linux-2.6.11 内核的书，说得很深，建议先提高自己的 C 语言编程水平再去看。
至于每个部分的移植网上也可以找到好多吨的资料，自己研究研究吧，不过要提醒的是，很多介绍自己经验的东西都或多或少有所保留，你按照他说的去做总有一些问题，但是他不会告诉你怎么解决，这时就要靠自己，如果自己都靠不住就找我一起研究研究吧，我也不能保证能解决你的问题，因为我未必遇到过你的问题，不过我相信能给你一点建议，也许有助你解决问题。
这一步的最终目的是，从源代码的官方主页上(都是外国的，悲哀)下载标准的源代码包，然后进行修改，最终运行在板子上。
盗用阿基米德的一句话：“给我一根网线，我能将 linux 搞定”。

        第五，研究 linux 驱动程序的编写。
移植系统并不是最终的目的，最终的目的是开发产品，做项目，这些都要进行驱动程序的开发。
Linux 的驱动程序可以说是五花八门，linux2.4 和 linux2.6 的编写有相当大的区别，就是同为 linux2.6 但是不同版本间的驱动程序也有区别，因此编写 linux 的驱动程序变都不是那么容易的事情，对于最新版本的驱动程序的编写甚至还没有足够的参考资料。那么我的建议就是使用、移植一个不算很新的版本内核，这样到时学驱动的编程就有足够的资料了。
这部分的推荐书籍可以参考另一篇文章《推荐几本学习嵌入式 linux 的书籍》。

        第六，研究应用程序的编写。
做作品做项目除了编写驱动程序，最后还要编写应用程序。现在的趋势是图形应用程序的开发，而图形应用程序中用得最多的还是 qt/e 函数库。我一直就使用这个函数库来开发自己的应用程序，不过我希望你能使用国产的 MiniGUI 函数库。盗用周杰伦的广告词就是“支持国产，支持 MiniGUI”。MiniGUI 的编程比较相似 Windows 下的 VC 编程，比较容易上手，效果应该说是相当不错的，我曾使用过来开发 arm7 的程序。不过 MiniGUI 最大的不好就是没有像 qtopia 这样的图形操作平台，这大大限制了他的推广，我曾经幻想过与北京飞漫公司(就是 MiniGUI 的版权拥有者)合作使用 MiniGUI 函数库开发像 qtopia 这样的图形操作平台，不过由于水平有限这只能是幻想了，呵呵。
完成这一步你基本就学完了嵌入式 linux 的全部内容了。
还有一个小小的经验想和大家分享。我在学习嵌入式 linux 的过程中很少问人，客观原因是身边的老师、同学师兄都没有这方面的高手，主观原因是我不喜欢问人，喜欢自己研究解决问题。这样做有个好处，就是可以提高自己解决问题的能力，因为做这些东西总有很多问题你难以理解，别人也没有这方面的经验，也不是所有问题都有人给你答案，这时必须要自己解决问题，这样，个人的解决问题能力就显得非常关键了。因此我的建议就是一般的问题到网上搜索一下，确实找不到答案了就问问高手，还是不行了就自己去研究，不要一味去等别人帮你解决问题。
记住，问题是学习的最好机会。







嵌入式系统Linux内核开发工程师必须掌握的三十个点

1)      Linux中主要有哪几种内核锁？

2)      Linux中的用户模式和内核模式是什么含意？

3)      怎样申请大块内核内存？

4)      用户进程间通信主要哪几种方式？

5)      通过伙伴系统申请内核内存的函数有哪些？

6)      通过slab分配器申请内核内存的函数有？

7)      Linux的内核空间和用户空间是如何划分的（以32位系统为例）？

8)      vmalloc()申请的内存有什么特点？

9)      用户程序使用malloc()申请到的内存空间在什么范围？

10)     在支持并使能MMU的系统中，Linux内核和用户程序分别运行在物理地址模式还是虚拟地址模式？

11)     ARM处理器是通过几级页表进行存储空间映射的？

12)     Linux是通过什么组件来实现支持多种文件系统的？

13)     Linux虚拟文件系统的关键数据结构有哪些？（至少写出四个）

14)     对文件或设备的操作函数保存在那个数据结构中？

15)     Linux中的文件包括哪些？

16)     创建进程的系统调用有那些？

17)     调用schedule()进行进程切换的方式有几种？

18)     Linux调度程序是根据进程的动态优先级还是静态优先级来调度进程的？

19)     进程调度的核心数据结构是哪个？

20)     如何加载、卸载一个模块？

21)     模块和应用程序分别运行在什么空间？

22)     Linux中的浮点运算由应用程序实现还是内核实现？

23)     模块程序能否使用可链接的库函数？

24)     TLB中缓存的是什么内容？

25)     Linux中有哪几种设备？

26)     字符设备驱动程序的关键数据结构是哪个？

27)     设备驱动程序包括哪些功能函数？

28)     如何唯一标识一个设备？

29)     Linux通过什么方式实现系统调用？

30)     Linux软中断和工作队列的作用是什么？











###################################################################################

1)      Linux中主要有哪几种内核锁？

	# 自旋锁、信号量
	# Linux内核中的同步机制：原子操作、信号量、读写信号量和自旋锁的API，另外一些同步机制，包括大内核锁、读写锁、大读者锁、RCU(Read-Copy Update，读-拷贝修改)和顺序锁。
	# 内核模式的代码可以无限制地访问所有处理器指令集以及全部内存和I/O空间。如果用户模式的进程要享有此特权，它必须通过系统调用向设备驱动程序或其他内核模式的代码发出请求。另外，用户模式的代码允许发送缺页，而内核模式的代码不允许。

2)      Linux中的用户模式和内核模式是什么含意？

	# 在Linux机器上，CPU要麽处于受信任的内核模式，要麽处于受限制的用户模式。除了内核本身处于内核模式以外，所有的用户都运行在用户模式之中。

3)      怎样申请大块内核内存？

	# 在Linux内核环境下，申请大块内存的成功率随着系统运行时间的增加而减少，虽然可以通过vmalloc系统调用申请物理不连续但虚拟地址连续的内存，但毕竟其使用效率不高且在32位系统上vmalloc的内存地址空间有限。所以，一般的建议是在系统启动阶段申请大块内存，但是其成功的概率也只是比较高而已，而不是100%。

4)      用户进程间通信主要哪几种方式？

	# 管道(Pipe)、命名管道(named pipe)、信号(Signal)、消息(Message)、共享内存、信号量(semaphore)、套接字(Socket)。

5)      通过伙伴系统申请内核内存的函数有哪些？

	# 在物理页面管理上实现了基于区的伙伴系统（zone base buddy system）。对于不同区的内存使用单独的伙伴系统管理，而且独立地监控空闲页。相应的接口alloc_pages(gfp_mask, order), __get_free_pages(gfp_mask, order)等。

6)      通过slab分配器申请内核内存的函数有？

	struct kmem_cache* kmem_cache_create(const char *name, size_t size, size_t align, unsigned long flags, void (*ctor)(void*))	该函数创建一个新的高速缓存

	void *kmem_cache_alloc(struct kmem_cache* cachep,gfp_t flags)	该函数从给定的高速缓存cachep中返回一个指向对象的指针。

	int kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)	该函数从给定的高速缓存cachep中返回一个指向对象的指针。

7)      Linux的内核空间和用户空间是如何划分的（以32位系统为例）？

	# 进程寻址空间0~4G，进程通过系统调用进入内核态

	# 通常32位Linux内核地址空间划分为0~3G为用户空间，3~4G为内核空间。
	# 32位系统用户进程最大可以访问3G内存，内核代码可以访问所有物理内存；
	  64位系统用户进程最大可以访问512G内存，内核代码可以访问所有物理内存。

8)      kmalloc和vmalloc()申请的内存有什么特点？

	##
	1. kmalloc和vmalloc是分配的是内核的内存地址；
	2. kmalloc保证分配的内存在物理上是连续的，当然在虚拟地址空间上也是连续的；
	3. vmalloc保证的是在虚拟地址空间上的连续，vmalloc()则是位于物理地址非连续，虚地址连续区，起始位置由VMALLOC_START来决定，一般作为交换区、模块的分配。

9)      用户程序使用malloc()申请到的内存空间在什么范围？

	# Linux下虚拟地址空间分给进程本身的是3G，那么一般程序使用malloc()申请到的内存空间最多3G，但是一般情况下是达不到的。

10)     在支持并使能MMU的系统中，Linux内核和用户程序分别运行在物理地址模式还是虚拟地址模式？

	# Linux内核程序运行在物理地址模式，Linux用户程序运行在虚拟地址模式。

11)     ARM处理器是通过几级页表进行存储空间映射的？

12)     Linux是通过什么组件来实现支持多种文件系统的？
	
	# VFS + VFS interface

13)     Linux虚拟文件系统的关键数据结构有哪些？（至少写出四个）

	# file_system_type / super_block / inode / file / dentry / vfsmount

14)     对文件或设备的操作函数保存在那个数据结构中？
	
	# file_operations

15)     Linux中的文件包括哪些？

	执行文件、普通文件、目录文件、链接文件、设备文件、管道文件

	# 有四种基本文件类型：普通文件、目录文件、链接文件和特殊文件。用file命令来识别。
	# 普通文件：如文本文件、C语言源码、shell脚本等，可用cat/less/more/vi等命令来查看内容，用mv改名。
	# 目录文件：包括文件名、子目录名及其指针。可用ls列出目录文件。
	# 链接文件：指向一个索引节点的哪些目录条目，用ls查看，链接文件的标志用l开头，而文件后以“->”指向所链接的文件。
	# 特殊文件：如磁盘、终端、打印机等都在文件系统中表示出来，常放在/etc目录中。

16)     创建进程的系统调用有那些？

	# clone() / fork() / vfork() / 
	系统调用哪个服务例程： sys_clone / sys_fork / sys_vfork

17)     调用schedule()进行进程切换的方式有几种？

	# 系统调用 do_fork()
	  定时中断 do_timer()
	  唤醒进程 wake_up_process()
	  改变进程的调度策略 setscheduler()
	  系统调用礼让 sys_sched_yield()

18)     Linux调度程序是根据进程的动态优先级还是静态优先级来调度进程的？

	# Linux调度程序是根据进程的动态优先级来调度进程的，但是动态优先级又是根据静态优先级根据算法计算出来的，两者是两个相关联的值。因为高优先级的进程总是比低优先级的进程先被调度，为防止多个高优先级的进程占用CPU资源，导致其他进程不能占用CPU，所以引用动态优先级概念。

19)     进程调度的核心数据结构是哪个？

	# runqueue

20)     如何加载、卸载一个模块？

	# 加载模块： sudo insmod **.ko / sudo dmesg |tail -n 1
	# 卸载模块： sudo rmmod ** / sudo dmesg | tail -n 1
	# 查看模块： lsmod |grep **

21)     模块和应用程序分别运行在什么空间？

	# 一个模块在内核空间运行，而应用程序在用户空间运行。

22)     Linux中的浮点运算由应用程序实现还是内核实现？

	# 应用程序实现，Linux中的浮点运算是利用数学库函数实现的，库函数能够被应用程序链接后调用，不能被内核链接调用。这些运算是在应用程序中运行的，然后再把结果反馈给系统。

23)     模块程序能否使用可链接的库函数？

	# 模块程序运行在内核空间，不能链接库函数。

24)     TLB中缓存的是什么内容？

	# TLB，页表缓存，当线性地址被第一次转换成物理地址的时候，将线性地址和物理地址的对应放在TLBB中，用于下次访问这个线性地址时，加快转换速度。

25)     Linux中有哪几种设备？

	# 字符设备、块设备、网络接口

26)     字符设备驱动程序的关键数据结构是哪个？

	字符设备描述符struct cdev, cdev_alloc() 用于动态的分配cdev 描述符，cdev_add() 用于注册一个cdev 描述符，cdev 包含一个struct kobject类型的数据结构，它是核心的数据结构。

	# cdev：	 代表一个字符设备驱动(char device, cdev)，每个字符设备驱动都有一个struct cdev 结构体变量与之对应，记录该设备驱动的相关信息，主要包括设备号dev_t dev 和设备操作函数集const struct file_operations *ops。
		struct cdev {
			struct kobject kobj;
			struct module *owner;
			const struct file_operations;
			struct list_head list;
			dev_t dev;
			unsigned int count;
		};

	# file_operations：	定义了设备驱动程序与用来访问内核之间的接口，该结构体定义的函数指来访问实际的硬件设备，不同的硬件设备具有不同的读写函数。

		struct file_operations {  
    			struct module *owner;  
    			loff_t (*llseek) (struct file *, loff_t, int);  
    			ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);  
    			ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);  
    			ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);  
    			ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);  
    			int (*readdir) (struct file *, void *, filldir_t);  
    			unsigned int (*poll) (struct file *, struct poll_table_struct *);  
    			long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);  
    			long (*compat_ioctl) (struct file *, unsigned int, unsigned long);  
    			int (*mmap) (struct file *, struct vm_area_struct *);  
    			int (*open) (struct inode *, struct file *);  
    			int (*flush) (struct file *, fl_owner_t id);  
    			int (*release) (struct inode *, struct file *);  
    			int (*fsync) (struct file *, int datasync);  
    			int (*aio_fsync) (struct kiocb *, int datasync);  
    			int (*fasync) (int, struct file *, int);  
    			int (*lock) (struct file *, int, struct file_lock *);  
    			ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);  
    			unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);  
    			int (*check_flags)(int);  
    			int (*flock) (struct file *, int, struct file_lock *);  
    			ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);  
    			ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);  
    			int (*setlease)(struct file *, long, struct file_lock **);  
		}; 
	
	# inode：表示一个文件节点，记录一个文件固有的通用信息，任何一个文件都有这个结构体变量。

	# file：表示一个已经打开的文件，记录打开文件的属性，包括读写属性，linux中一切皆文件，但是文件一般分为磁盘文件和特殊文件（设备文件）

27)     设备驱动程序包括哪些功能函数？

	# 设备驱动有： open() / read() / write() / llseek() / release()

28)     如何唯一标识一个设备？

	# 在设备管理中，除了设备类型外，内核还需要一对被称为主从设备号的参数，才能唯一标识一个设备。

	# 主设备号： 用于标识驱动程序，相同的主设备号使用相同的驱动程序。
	  从设备号： 用于标识同一驱动程序的不同硬件。

	# 在内核中用dev_t 来表示设备编号，一般它是32位 长度，其中12位用于表示主设备号，20位用于表示次设备号，利用MKDEV(int major, int minor)生成一个dev_t类型的对象。

29)     Linux通过什么方式实现系统调用？

	靠软件中断实现

	# Linux中实现系统调用利用了0x86体系结构中的软件中断。软件中断和我们常说的中断（硬件中断）不同之处在于，它是通过软件指令触发而并非外设引发的中断，也就是说，是编程人员开发出的一种异常（正常的异常），具体的讲就是调用int$0x80汇编指令，这条汇编指令将产生向量为0x80的编程异常。

	之所以系统调用需要借助异常来实现，是因为当用户态的进程调用一个系统调用时，CPU便被切换到内核态执行内核函数，而我们在i386体系结构部分已经知道了 进入内核 -- 进入高特权级别 -- 必须经过系统的 门机制，这里个异常实际上就是通过系统门陷入内核（除了int 0x80外用户空间还可以通过int3 -- 向量3、into -- 向量4、bound -- 向量5等异常指令进入内核，而其他异常无法被用户空间程序利用，都是有系统使用的）。

	更详细地解释一下这个过程。int $0x80指令的目的是产生一个编号为0x80的编程异常，这个编程异常对应的是中断描述符表IDT中的第128项 -- 也就是对应的系统门描述符。门描述符中含有一个预设的内核空间地址，它指向了系统调用处理程序：system_call()（不要和系统调用混淆，这个程序在entry.S文件中用汇编语言编写）。

	很显然，所有的系统调用都会统一地转到这个地址，但Linux一共有两三百个系统调用都从这里进入内核后有该如何派发到它们各自的服务程序去呢？解决这个问题的方法非常简单：首先，Linux为每个系统调用都进行了编号（0~NR_syscll），同时在内核中保存一张系统调用表，该表中保存了系统调用编号和其对应的服务例程，因此在系统调用通过系统门陷入内核前，需要把系统调用号一并传入内核，在x86上，这个传递动作是通过在执行int0x80 前把调用号装入eax 寄存器实现的。这样，系统调用处理程序一旦运行，就可以从eax 中得到数据，然后再区系统调用表中寻找相应服务例程了。

	除了需要传递系统调用号外，许多系统调用还需要传递一些参数到内核，比如sys_write(unsigned int fd, const char *buf, size_t count) 调用就需要传递文件描述符fd、要写入的内容buf 以及写入字节数count 等几个内容到内核。碰到这种情况，Linux会有6个寄存器可被用来传递这些参数：eax（存放系统调用号）、ebx、ecx、edx、esi及edi来存放这些额外的参数。具体做法是在system_call() 中使用SAVE_ALL 宏把这些寄存器的值保存在内核态堆栈中。

	备注：
	系统调用其实很简单，就是所有操作系统的API都是通过软件的中断动态的调用，通过调用int $0x80 触发软件中断，然后通过一些寄存器将参数传入，实现对操作系统API的调用。
	在嵌入式操作系统中有软中断的概念，该软中断是指将硬中断中次优先级的任务交给软中断处理，其运行与系统栈中，优先级高于任务，和这里说的软件中断有很大区别，软件中断处理和硬中断处理流程相同，只是该中断由软件触发。

30)     Linux软中断和工作队列的作用是什么？

	# Linux中的软中断和工作队列是中断处理。

	1、 软中断一般是“可延迟函数”的总称，它不能睡眠，不能阻塞，它处于中断上下文，不能进程切换，软中断不能被自己打断，只能被硬件中断打断（上半部），可以并发的运行在多个CPU上。所以软中断必须设计成可重入的函数，因此也需要自旋锁来保护其数据结构。

	2、 工作队列中的函数处在进程上下文中，它可以睡眠，也能阻塞，能够在不同的进程间切换，以完成不同的工作。可延迟函数和工作队列都不能访问用户的进程空间，可延时函数在执行时不可能有任何正在运行的进程，工作队列的函数在内核进程执行，，它不能访问用户空间地址。





##################  拓展  #####################

1、内核模块与应用程序的对比

		用户态程序		内核模块
	运行	用户空间			内核空间
	入口	main()			module_init()指定
	出口	无			module_exit()指定
	编译	gcc-c			Makefile
	连接	ld			insmod
	运行	直接运行			insmod
	调试	gdb			kdbug/kdb/kgdb等

    调用函数对比：
	程序员并不总是自己写所有用到的函数。一个常见的例子就是printf()，使用这些C标准库，libc提供的库函数。这些函数实际上在连接之前并不进入你的程序。在连接时这些函数调用才会指向你调用的库，从而使你的代码最终可以执行。
	内核模块有所不同。在模块中使用函数printk()没有包含标准I/O库。这是因为模块是在insmod加载时才连接的目标文件。那些要用到的函数的符号链接是内核自己提供的。也就是说，你可以在内核模块中使用的函数只能来自内核本身。如果你对内核提供了哪些函数符号链接感兴趣，可以看看文件/proc/kallsyms。

    库函数和系统调用的区别：
	库函数是高层的，完全运行在用户空间，为程序员提供调用更方便的接口，而真正在幕后完成实际事务的是系统调用。系统调用在内核态运行并且由内核自己提供。标志C库函数printf()可以被看做是一个通用的输出语句，但它实际做的是将数据转化为符合格式的字符串并且调用系统调用write()输出这些字符串。（可以用调试工具strace命令，它可以接管被跟踪进程执行的系统调用和收到的信号，然后把每一个执行的系统调用的名字，参数和返回值打印出来。）
	一般库函数在用户态执行。库函数调用一个或几个系统调用，而这些系统调用为库函数完成工作。

    内存对比：
	用户编程：使用malloc()和free()函数申请和释放内存
	内核模块：进行内核编程时，最常用的内存申请和释放函数为在include/linux/kernel.h文件中声明的kmalloc()和kfree()，其原型为：
		void *kmalloc(unsigned int len, int priority);
		void kfree(void *ptr);
	参数说明：
		kmalloc的priority参数通常设置为GFP_KERNEL，如果在中断服务程序里申请内存则用GFP_ATPMIC参数，因为使用GFP_KERNEL参数可能会引起睡眠，不能用于非进程上下文中（在中断中是不允许睡眠的）。
	说明：
		由于内核态和用户态使用不同的内存定义，所以二者之间不能直接访问对方的内存。而应该使用Linux中的用户态和内核态内存交互函数（在include/asm/uaccess.h中被声明）：
		unsigned long copy_from_user(void *to, const void *from, unsigned long n);
		unsigned long copy_to_user(void *to, void *from, unsigned long len);
		copy_from_user copy_to_user函数返回不能被复制的字节数，因此，如果完全复制成功，返回值为0。
		include/asm/uaccess.h中定义的put_user和get_user用于内核空间和用户空间的单值交互（如char、int、long）。

	其他：
		一种内核模块是设备驱动程序，为使用硬件设备而编写。在Unix中，任何设备都被当作路径/dev的设备文件处理，并通过这些设备文件提供访问硬件的方法。设备驱动为用户程序访问硬件设备。
		在Linux中，设备大致可分为：字符设备，块设备和网络接口。

		字符设备，包括那些必须以顺序方式，像字节流一样被访问的设备，如字符终端，串口等；
		块设备，是指那些可以用随机方式，以整块数据为单位来访问的设备，如硬盘等；
		网络接口，就指通常网卡和协议栈等复杂的网络输入输出服务。






























嵌入式程序员应该知道的十六个问题

1	预处理器（Preprocessor）
2	如何定义宏
3	预处理器标识#error的目的是什么
4	死循环（Infinite loops）
5	数据声明（Data declarations）
6	关键字static的作用是什么
7	关键字const有什么含义
8	Volatile的使用
9	位操作（Bit manipulation）
10	访问固定的内存位置（Accessing fixed memory locations）
11	中断（Interrupts）
12	符号扩展的代码例子
13	处理器字长导致的数据扩展问题
14	动态内存分配（Dynamic memory allocation）
15	用Typedef构造复合类型
16	晦涩的语法及代码风格








############################################################################

1	预处理器（Preprocessor）

	用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
	#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL（大小写都行，常量后面可以加此标志，宏的命名风格要大写，多个之间用下划线）
	我在这想看到几件事情：
	1) #define 语法的基本知识（例如：不能以分号结束，括号的使用（表达式、参数等要括起来），等等）
	2)懂得预处理器将为你计算常数表达式的值（难道不是替换么，先算再替？会将常数合并），因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
	3) 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
	4) 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。

2	如何定义宏

	写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。
	考点：（表达式、参数等要括起来）
	#define MIN(A,B) （（A） <= (B) ? (A) : (B))
	这个测试是为下面的目的而设的：
	1) 标识#define在宏中应用的基本知识。这是很重要的。因为在嵌入(inline)操作符变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能（当然主要是实时性哦，牺牲代码空间换取时间效率），嵌入代码经常是必须的方法。
	2)三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else（存在条件转移会中断指令流水线）更优化的代码，了解这个用法是很重要的。
	3) 懂得在宏中小心地把参数用括号括起来
	4) 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
	least = MIN(*p++, b);
 
	此处考点：inline函数和宏的区别
	宏只是将参数完全替换，即MIN(*p++, b)进行宏展开后为（（*p++） <= (b) ? (*p++) : (b))，如果（*p++） <= (b)成立，则表达式的值为(*p++)，但由于在（*p++）<= (b)判断过程中改变了p的值，使得此时的? (*p++)非（*p++）<= (b)中的值了，违背了？号表达式的原意。
	但是内联inline函数将进行参数检查，求出参数的值后再将此值带入函数中，因此（（A） <= (B) ? (A) : (B))中的A是一致的。
 
	第一部分：宏
	为什么要使用宏呢？
	因为函数的调用必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。
	而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。
	但是宏也有很多的不尽人意的地方：
		1、宏不能访问对象的私有成员。
		2、宏的定义很容易产生二意性。
		3、宏定义的常量在代码区，很多调试器不能够对其调试
	我们举个例子：
	#define square(x) (x*x)
	避免这些错误的方法，一是给宏的参数都加上括号。
	#define square(x) ((x)*(x))

	第二部分：内联函数
	从上面的阐述，可以看到宏有一些难以避免的问题，怎么解决呢？
	内联函数是代码被插入到调用者代码处的函数。如同 #define 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（“过程化集成”）被编译器优化。

	内联函数和宏很类似，而本质区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。
	声明内联函数看上去和普通函数非常相似：
	void f(int i, char c);
	当你定义一个内联函数时，在函数定义前加上 inline 关键字，并且将定义放入头文件：
	inline void f(int i, char c)
	{
		// ...
	}
	内联函数必须是和函数体的定义申明在一起，才有效。
	像这样的申明inline function(int i)是没有效果的，编译器只是把函数作为普通的函数申明，我们必须定义函数体。
	inline int function(int i) {return i*i;}
	这样我们才算定义了一个内联函数。我们可以把它作为一般的函数一样调用。但是执行速度确比一般函数的执行速度要快。

	当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。
	有上面的两者的特性，我们可以用内联函数完全取代预处理宏。

3	预处理器标识#error的目的是什么

4	死循环（Infinite loops）

	嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？这个问题有几个解决方案。
	我首选的方案是：
	while (1) {
	    ......
	}
	一些程序员更喜欢如下方案：
	for (;;) {	// 此处的判断效率要低得多，在汇编代码中可以体现
	    ......
	}
	这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想过为什么。”这会给我留下一个坏印象。（很多时候面试官关注你思考问题的方式，是否留意某些东西善于思考，可能并没有对错，只是偏好而已，比如memset和memcopy以及strcpy都能拷贝字符串，到底有什么区别呢？看你是否善于比较是否关注细节）

	第三个方案是用goto（goto语句在C中是应该尽量避免的，只在处理错误代码时用）
	Loop:
	    ......
	    ......
	goto Loop;
	应试者如给出上面的方案，这说明或者他是一个汇编语言程序员或者他是一个想进入新领域的BASIC/FORTRAN程序员。

5	数据声明（Data declarations）

	用变量a给出下面的定义
	a) 一个整型数（An integer）
	b) 一个指向整型数的指针（A pointer to an integer）
	c) 一个指向指针的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）
	d) 一个有10个整型数的数组（An array of 10 integers）
	e) 一个有10个指针的数组，该指针是指向一个整型数（An array of 1 pointers to integers）
	f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）
	g)  一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）
	h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（An array of 10 pointers to functions that take aninteger argument and return an integer）
	答案是：
	a) int a;
	b) int *a;
	c) int **a;
	d) int a[10];
	e) int *a[10];
	f) int (*a)[10];
	g) int (*a)(int);
	h) int (*a[10])(int);

6	关键字static的做用是什么

	这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
	1) 在函数体内，一个被声明为静态的变量在这一函数被调用过程中维持其值不变（该变量存放在静态变量区）。
	2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其他函数访问。它是一个本地的全局变量。
	3) 在模块内，一个被声明为静态的函数只可以被这一模块内的其他函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。

	大多数应试者能正确回答第一部分，一部分能正确回答第二部分，但是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。

	考点：
	在嵌入式系统中，要时刻懂得移植的重要性，程序可能是很多程序员共同协作同时完成，在定义变量及函数的过程，可能会重名，这给系统的集成带来麻烦，因此保证不冲突的方法是显式的表示此变量或者函数是本地的，static即可。
	在Linux的模块编程中，这一条很明显，所有的函数和全局变量都要用static关键字声明，将其作用域限制在本模块内部，与其他模块共享的函数或者变量要EXPORT 到内核中。

	static关键字至少有下列N个作用：
	1) 设置变量的存储域，函数体内static变量的作用范围为该函数体，不用于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
	2) 限制变量的作用域，在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其他函数访问；
	3) 限制函数的作用域，在模块内的static函数值可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内；
	4) 在类中的static成员变量意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改之为该类的其他所有实例所见；
	5) 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。
	

7	关键字const有什么含义

	我只要一听到被面试者说，“const意味着常熟”，我就知道我正在和一个业余者打交道。一般只要能说出const意味着“只读”就可以了。如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？
	const只是一个修饰符，不管怎样a仍然是一个int型的变量
	const int a;
	int const a;
	const int *a;
	int * const a;
	int const * a const;
	本质：const在谁后面谁就不可修改，const在最前面则将其后移一位即可，二者等效。

	前两个的作用是一样的，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是说，指向的整型数是不可修改的，但指针可以，此最常见于函数的额参数，当你只引用传进来指针所指向的值时应该加上const修饰符，程序中修改编译就不通过，可以减少程序的bug）。

	第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。

	如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，及时不用关键字，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我有如下的几个理由：
	1) 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其他人留下的垃圾，你就会很快学会感谢这点多余的信息。
	2) 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
	3) 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。

	const关键字至少有下列N个作用：
	1) 欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因此以后就没有机会再去改变它了；
	2) 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
	3) 在一个函数声明中，const可以修饰形参，声明它是一个输入参数，在函数内部不能改变其值；
	4) 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
	5) 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：
	const classA operator*(const classA& a1, const classA& a2);
		operator*的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错。
	classA a, b, c;
	(a * b) = c;	// 对a*b的结果赋值
		操作(a * b) = c 显然不符合编程者的初衷，也没有任何意义。


8	Volatile的使用

	关键字volatile有什么含义？
	一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份（由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化）。下面是volatile变量的几个例子：
	1) 并行设备的硬件寄存器（如：状态寄存器，通常在头文件中将硬件寄存器地址define为某个意义明确的表达式）
	2) 一个中断服务子程序中会访问到的非自动变量（Non-automatic variables，即static变量）；在中断服务程序中修改的供其他程序检测用的变量需要加volatile声明；否则编译器可能对变量更新一次后每次都使用缓存值不再立即更新
	3) 多线程应用中被几个任务共享的变量（可能被多个线程随时修改）

	回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。假设被面试者正确地回答了这些问题，我将稍微深究一下，看一下这家伙是不是真正懂得vkolatile完全的重要性。
	1) 一个参数既可以是const还可以是valatile吗？
	2) 一个指针可以是volatile吗？
	3) 下面的函数有什么错误：
		int square(volatile int *ptr) {
			return *ptr * *ptr;
		}
	答案：
	1) 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
	2) 是的。尽管这并不常见。一个例子是当一个中断服务子程序修改一个指向一个buffer的指针时。
	3) 这段代码有点变态。它的目的是返回指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
		int square(volatile int *ptr) {
			int a, b;
			a = *ptr;
			b = *ptr;
			return a * b;
		}
	由于*ptr的值可能被意想不到地改变，因此a和b可能是不同的。结果，这段代码可能返回不是你所期望的平方值。正确的代码如下：
		int square(volatile int *ptr) {
			int a;
			a = *ptr;
			return a * a;
		}
	
	定义一个易失性变量，编译器有一种技术叫数据流分析，分析程序中的变量在哪里被赋值、在哪里使用、在哪里师表，分析结果可用用于常量合并，常量传播等优化。当编译器检查到代码没有修改字段的值，就有可能在你访问字段时提供上次访问的缓存值，这能够提高程序的效率，但有时这些优化会带来问题，不是我们程序所需要的，特点是对硬件寄存器操作的程序，这时可以用volatile关键字禁止做这些优化。

	多任务环境下个任务间共享的标志应该加volatile关键字：在多线程访问某字段时，代码希望这些访问能够操作（读取）到字段的最新值，同时写到变量的操作能立即更新；对字段加上volatile关键字，那么对该字段的任何请求（读/写）都会立刻得到执行。


9	位操作（Bit manipulation）

	嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3， 第二个清除a的bit 3.在以上两个操作中，要保持其他位不变。对这个问题有三种基本的反应
	1) 不知道如何下手。该面试者从没做过任何嵌入式系统的工作。
	2) 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。
	3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
		#define BIT3 (0x1 << 3) （采用宏将数字定义为有意义的BIT3，明确，不易出错，改起来方便）
		static int a;
		void set_bit3(void) {
			a |= BIT3;
		}
		void clear_bit3(void) {
			a &= ~BIT3;
		}

	一些人喜欢为设置和清除值而定义一个掩码（待操作位全1，其余位全0的数，对于某个意思靠多位同时表示的最好带上掩码，隔离其他位的影响）同时定义一些说明常熟，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作，先取反再&是对某位清0的最好操作。

	考点：
	在嵌入式系统中，时刻要关注移植性，具体的程序中不要出现具体的数字，这些数字都应该define成某个有意义的符号，可读性可移植性都很强，比如
		#define BIT(x) (0x1 << (x))
	X作为参数可以很方便的对任意位进行操作，意义明确，更改替换方便
 
10	访问固定的内存位置（Accessing fixed memory locations）

	嵌入式系统经常具有要求程序员去访问某特定的内存位置的特定。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
		int *ptr;
		ptr = (int *)0x67a9;
		*ptr = 0xaa55;
		A more obscure approach is: ( 一个较晦涩的方法是)：
		*(int * const)(0x67a9) = 0xaa55;
	即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。
 
	在嵌入式系统中，对于大量此类型数据如硬件寄存器应该采用如下方式
	typedef volatile unsigned int HARD_REG;
	#define REG_NAME  (*(HARD_REG *)ADDR)
	即将ADDR强制转换为一个指向HARD_REG类型数据的指针，*HARD_REG为volatile的无符号整型数


11	中断（Interrupts）

	中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展-让标准C支持中断。其代表事实是，产生一个新的关键字__interrupt（51即如此）。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
		__interrupt double compute_area (double radius) {
			double area = PI * radius * radius;
			printf("/nArea = %f", area);
			return area;
		}
	这个函数有太多的错误，以至于让人不知从何说起（前提是非操作系统下的中断服务函数）：
	1) ISR不能返回一个值（都应该为void类型）
	2) ISR不能传递参数。
	3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，有些处理器/编译器就是不允许ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
	///////////////////
	另外，中断服务程序是运行在内核态的（Linux），内核通常是不支持浮点运算的。
	内核中的printk和标准库的printf不一样，前者因为由内核直接实现，不能支持浮点。
	如果你的内核里编译进了浮点支持，那么是可以的。要不内核或是模块不能用float或是double内型的变量或函数。

	在配置内核的时候把浮点模拟器选上，应该是可以支持的，但是速度非常慢。 
	我曾经遇到过，硬件明明支持浮点运算的FPU，但是编译内核的时候选上了浮点模拟器，结果所有的应用程序的浮点运算速度都非常慢。所以我怀疑要支持浮点只要编译内核的时候选上，对于应用程序不需要怎么关心。

	4) 与第三点一脉相承，printf()经常有重入和性能上的问题。

12	符号扩展的代码例子（Code examples）

	下面的代码输出是什么？
		void foo(void) {
			unsigned int a = 6;
			int b = -20;
			 
			(a+b > 6) ? puts(">6") : puts("<6");
			printf("unsigned int a + int b = %x/n", (a + b));
		}
		/* unsigned int a + int b = fffffff2 */

	这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 ">6"。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于频繁用到无符号数据类型的嵌入式系统（硬件寄存器的值全部是无符号的）来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。

13	处理器字长导致的数据扩展问题

	评价下面的代码片段：
		unsigned int zero = 0;
		unsigned int compzero = 0xFFFF;
		/* 1's complement of zero */ 0的补码为全1的数

	对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：
	unsigned int compzero = ~0;
	这一问题真正能揭露出应试者是否懂得处理器字长的重要性（嵌入式平台可能是8、16、32的，移植的角度来说写出固定的0xFFFF是不对的）。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。

	到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法（很重要哦，面试者关注的是你思考问题解决问题的过程，当你不知道答案时千万千万不要猜一个答案给他，因为现在不是选择题，面试官要的是过程，你只需要将你考虑问题的过程说明白就OK了），而不是答案。不管如何，你就当是这个娱乐吧...


14	动态内存分配（Dynamic memory allocation）
	
	尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆(heap)中动态分配内存的过程。那么嵌入式系统中，动态分配内存可能发生的问题是什么？这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？

		char *ptr;
		if ((ptr = (char *)malloc(0)) == NULL) 
			puts("Got a null pointer");
		else
			puts("Got a valid pointer");
	
	这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是"Got a valid pointer"。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确（因为如果申请失败，则程序处理认为内存不足了，一般会终止程序，是很严重的问题？）。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。
	返回一控指针还是指向 0 字的指甚至指向一个可以操作的指针？
	（取决于系统平台的实现，C99及其他标准规定可以不同的）

15	用Typedef构造复合类型

	在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。
		
		#define dPS strcut s *
		typedef struct s * tPS;
	以上两种情况的意图都是要定义dPS 和tPS 作为一个指向结构s指针。哪种方式更好呢？

	这是一个非常微妙的问题，任何人答对这个问题（正当的原因哦，而不是猜，如果你没有原因，说不会比猜一个答案要好的多，记住啊，说话是要讲根据的）是应当被恭喜的。答案是：typedef更好。思考下面的例子：
		
		dPS p1, p2;
		tPS p3, p4;
	第一个扩展为 
		struct * p1, p2;

	上面的代码定义p1为一个指向结构的指针，p2为一个实际的结构，这也许不是你想要的。第二个例子正确第定义了p3和p4两个指针。

16	晦涩的语法及代码风格

	C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
		int a = 5, b = 7, c;
		c = a+++b;
	这个问题将作为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，编译器应尽可能多的从左至右将若干戈字符组成一个运算符。因此，上面的代码被处理成： c = a++ + b;
	都好表达式依次对每个表达式计算，最后的结果为最后一个表达式的值。因此，执行后 a = 6, b = 7, c = 12。

	如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格（要明确的加上括号，避免歧义或者编译器不同带来的差异），代码的可读性，代码的可修改性的好的话题。


####################################################

	注：
	引出代码风格的问题正是作者问此问题的目的，这告诉我们要揣摩面试管每个问题背后隐藏的考查点，能够趁机发挥下就大功告成了！