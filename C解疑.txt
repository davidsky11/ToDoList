一、指针

指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。 要搞清一个指针需要搞清指针的四方面的内容：
1.指针的类型
2.指针所指向的类型
3.指针的值或者叫指针所指向的内存区
4.还有指针本身所占据的内存区
先声明几个指针放着做例子：
例一：
(1)int *ptr;
(2)char *ptr;
(3)int **ptr;
(4)int (*ptr)[3];
(5)int *(*ptr)[4];
1.1 指针的类型
      从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。所以分析下例一中各个指针的类型：
(1)int *ptr; //指针的类型是int *
(2)char *ptr; //指针的类型是char *
(3)int **ptr; //指针的类型是 int **
(4)int (*ptr)[3]; //指针的类型是 int(*)[3]
(5)int *(*ptr)[4]; //指针的类型是 int *(*)[4]
所以找出指针的类型的方法是不是很简单？
1.2 指针所指向的类型
     当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符 *去掉，剩下的就是指针所指向的类型。例如：
(1)int *ptr; //指针所指向的类型是int
(2)char *ptr; //指针所指向的的类型是char
(3)int **ptr; //指针所指向的的类型是 int *
(4)int (*ptr)[3]; //指针所指向的的类型是 int()[3]
(5)int *(*ptr)[4]; //指针所指向的的类型是 int *()[4]
在指针的算术运算中，指针所指向的类型有很大的作用。
    指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当对C越来越熟悉时，你会发现，把与指针搅和在一起的“类型”这个概念分成“指针的 类型”和“指针所指向的类型”两个概念，是精通指针的关键点之一。有些教材书上写得很差，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。






二、常量指针与指针常量

常量指针是指--指向常量的指针，顾名思义，就是指针指向的是常量，即，它不能指向变量，它指向的内容不能被改变，不能通过指针来修改它指向的内容，但是指针自身不是常量，它自身的值可以改变，从而指向另一个常量。
指针常量是指--指针本身是常量。它指向的地址是不可改变的，但地址里的内容可以通过指针改变。它指向的地址将伴其一生，直到生命周期结束。有一点需要注意的是，指针常量在定义时必须同时赋初值。
注：也有人将这两个名称的定义与含义反过来认为：“指针常量：顾名思义它的中心词是“常量”这是重点，指针就是一个修饰的作用。所以这里的指针还是一个变量，它的内容存放的是常量的地址。常量指针：关键字是指针，它是不能被改变的，因为指针总是指向地址的，所以它的意思是它指向的地址是不能被改变的”。但我个人认为后者不合理，所以使用前者。
2.使用方法：
使用时写法上的区别：常量指针：const在*之前   指针常量：const在*之后。
  当然我们也可以定义常量指针常量，那就需要加上两个const，一前一后！以上只是从定义上给出两者的本质上的不同，在具体使用上，还有很多变化，但万变不离其宗，我们可以根据它的原理分析出各种复杂用法的实质。
3. 使用举例
3.1 常量指针使用：
如intb, c;
int const *a; 
a = &b;
a = &c;
都可以，唯独它指向的内存不能被修改。如：*a=20;这是违法的！错误！
3.2 指针常量使用
如Inta;
Int aTest;
Int * const p =&a;
表示p是一个常量指针它指向变量a的内存。指针常量不能再用p指向其他变量，如p= & aTest; 错误！可以修改指向内存的值，如:*p = 20;指针常量声明的时候必须向我那样赋初值。
指针常量也不能释放,用p指向NULL，即
p= NULL;
会在编译时报错
/opt/test/test.c:649:error: assignment of read-only variable`p'
还有一个记住他们不同形式的技巧！看const关键字，他后面的不可修改，如int* const a = &b; 后面是a,则说明a不能修改！
intconst * a = &b;后面是*a则说明*a不可被修改！
在好多书上或MSDN是经常用constint a=5; int b=6; const int *p=&b; 
其实constint*和intconst*一样，就是常量指针也就是它所指向的数据（在这是int）是常量，它自己的数据类型是constint*
还有constint *p=&b;是可以的虽然b不是常量。但是constint a=6; int *p=&a;会报错，因为它消除了a的const属性
4.使用技巧
使用指针常量可以增加代码的可靠性和执行效率。
如Inta;
Int * const p =&a;
增加可靠性：不用担心p被修改或释放导致非预期结果；
增加执行效率：不用在子函数中对p做为空检查可以提高效率。









三、对"typedef int (*funcptr)();" 的理解

它定义了一个类型funcptr，表示指向返回值为int型（参数未指明）的函数的指针。它可以用来声明一个或多个函数指针。
	funcptr fp1, fp2;
这个声明等价于以下这种更冗长而且可能更难理解的写法：
	int (*fp1)(), (*fp2)();






四、weak_alias和strong_alias

=========================     [glibc/include/libc-symblos.h]     ===========================

#ifndef __ASSEMBLER__
/* GCC understands weak symbols and aliases; use its interface where
   possible, instead of embedded assembly language.  */

/* Define ALIASNAME as a strong alias for NAME.  */
# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
# define _strong_alias(name, aliasname) \
  extern __typeof (name) aliasname __attribute__ ((alias (#name)));

/* This comes between the return type and function name in
   a function definition to make that definition weak.  */
# define weak_function __attribute__ ((weak))
# define weak_const_function __attribute__ ((weak, __const__))

# ifdef HAVE_WEAK_SYMBOLS

/* Define ALIASNAME as a weak alias for NAME.
   If weak aliases are not available, this defines a strong alias.  */
#  define weak_alias(name, aliasname) _weak_alias (name, aliasname)
#  define _weak_alias(name, aliasname) \
  extern __typeof (name) aliasname __attribute__ ((weak, alias (#name)));
  
/* Same as WEAK_ALIAS, but mark symbol as hidden.  */
#  define weak_hidden_alias(name, aliasname) \
  _weak_hidden_alias (name, aliasname)
#  define _weak_hidden_alias(name, aliasname) \
  extern __typeof (name) aliasname \
    __attribute__ ((weak, alias (#name), __visibility__ ("hidden")));






四、static、extern和const

变量的定义一定也是变量的初始化，反之则不成立，在一定的作用域中，变量的声明可以有多个，但是定义只有一个

    1. 变量在定义时分配内存空间，同时也可能赋予初值；
    2. 变量在声明时不会分配内存空间，说明该变量时存在的，指出了该变量的名字和位置。其作用是声明该变量是已在程序后面定义的变量

    extern int i;	声明外部变量
    int i;		定义变量

static的用法：
    
    1. 修饰函数，使其成为静态函数，在此static并非指存储方式，只是说明该函数的作用域只是局限于本文件；
    2. 修饰局部变量，成为静态局部变量，存储在静态区，即使函数运行结束，静态变量的值不会被销毁，下次调用该函数时，值仍存在；
    3. 修饰全局变量，成为静态全局变量，存储在静态区，作用域仅限于变量被定义的文件中，其他文件即使使用extern也无法调用。


const修饰的只读变量与常量的区别：
 
    1. 常量是一个静态的值，不需要分配内存，enum类型和#define（注意define不是关键字）宏声明一个常量；常量需要分配内存；
    2. const修饰的只读变量不能用来作为定义数组的维数，也不能放在case关键字后面；
    3. 常量是永远无法改变的，但是只读变量一般无法直接在此赋值，但是可以通过指针改变。

const的好处:

    1. 修饰函数的参数可以防止参数以外改动，增加程序的健壮性；
    2. 修饰只读变量同时进行初始化，此后此常量不再改变，可以节省空间，避免不必要的内存空间分配，提高效率；
    3. 修饰函数体时，表示是一个常函数，不能改变其中变量的值。



使用extern static const定义全局变量的差异和用法：

    1. 若要求某个文件中的全局变量是任何其他文件共享的，只要在头文件中extern声明一下，在某一个文件定义下，任何文件均可以共享这个全局变量；	在头文件中，只能对外部全局变量进行声明，而不能定义，否则，在编译过程中会提示出现重复定义的作物，因为多个.c文件都包含了头文件；
    2. 若在定义全局变量前加static，说明该变量只有该文件内部可以使用，其他文件无法使用；
        static和extern不能同时定义一个相同的变量；
	用static定义的全局变量（函数），只作用在本文件中，其他文件不能使用；
	一般static定义全局变量在源文件中，而不放置在头文件中；


使用extern static const定义局部变量的差异和用法：

    1. 用static定义局部变量时，改变了局部变量的生命周期（作用域仅限于函数）；
    2. 普通的局部变量存放在内存的动态区（栈区），静态的局部变量存在内存的静态区，地址不再随着函数调用的结束而消失，而是等整个程序结束后才消失。
    3. 不要extern在定义一个局部变量，没有意义

关于const：

    除了定义只读变量，可以用于修饰函数的参数，返回值，函数的定义体，以此来提高函数的健壮性。

通常const只修饰作为输入的参数：

    1. 参数为指针传递时：如：strcpy(char *strdes,const char*strsource);/*防止意外改动输入参数strsource的内容*/
    2. 参数为至传递时：通常不用const修饰，会自动产生一个临时变量来复制输入参数，而不会改变原值。
    3. 参数为引用传递时，情况通指针传递  void func(const int& a);

用于修饰函数的返回值：

    1. 若const 用于修饰指针传递方式的函数返回值，则返回指针值就不能被修改，同样要用const修饰的同类指针接受返回值；如： const int* String(int * r);  const int* p=String(ptr);
    2. 若是值传递，返回值在临时的存储区，一般不用const修饰；
    3. 若是引用传递，情况与指针类似，但是容易出错（慎用）；

    内部函数 ―― 一个函数只能被本文件调用，在定义和声明的时候加上关键字static，作用是多个文件中的同名函数不相互干扰；
    外部函数 ―― 可以被其他文件调用的函数，定义是加上关键字extern，在其他文件中用extern声明该函数。












五、inline函数的使用方法

    inline关键字用来定义一个类的内联函数，引入它的主要原因是用它替代C中表达式的宏定义。
    表达式的宏定义如下：
    #define ExpressionName(Var1,Var2) ((Var1)+(Var2))*((Var1)-(Var2))
    
    为什么要取代这种形式呢，且听我道来：
	1． 首先谈一下在C中使用这种形式宏定义的原因，C语言是一个效率很高的语言，这种宏定义在形式及使用上像一个函数，但它使用预处理器实现，没有了参数压栈，代码生成等一系列的操作,因此，效率很高，这是它在C中被使用的一个主要原因。
	2． 这种宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。
	3． 在C++中引入了类及类的访问控制，这样，如果一个操作或者说一个表达式涉及到类的保护成员或私有成员，你就不可能使用这种宏定义来实现(因为无法将this指针放在合适的位置)。
	4． inline 推出的目的，也正是为了取代这种表达式形式的宏定义，它消除了宏定义的缺点，同时又很好地继承了宏定义的优点。

    预定义

    对于上面的1-3点，阐述如下：
	1． inline 定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，（像宏一样展开），没有了调用的开销，效率也很高。
	2． 很明显，类的内联函数也是一个真正的函数，编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。
	3． inline 可以作为某个类的成员函数，当然就可以在其中使用所在类的保护成员及私有成员。

    在何时使用inline函数：
	首先，你可以使用inline函数完全取代表达式形式的宏定义。
	另外要注意，内联函数一般只会用在函数内容非常简单的时候，这是因为，内联函数的代码会在任何调用它的地方展开，如果函数太复杂，代码膨胀带来的恶果很可能会大于效率的提高带来的益处。内联函数最重要的使用地方是用于类的存取函数。

    使用方法

    （一）C++ inline函数
	在函数声明或定义中函数返回类型前加上关键字inline即把min（）指定为内联。
	inline int min(int first, int secend) {};
	inline 函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。当然，对于同一程序的不同文件，如果C++ inline函数出现的话，其定义必须相同。对于由两个文件compute.C和draw.C构成的程序来说，程序员不能定义这样的min()函数，它在compute.C中指一件事情，而在draw.C中指另外一件事情。如果两个定义不相同，程序将会有未定义的行为：
	为保证不会发生这样的事情，建议把inline函数的定义放到头文件中。在每个调用该inline函数的文件中包含该头文件。这种方法保证对每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命期中引起无意的不匹配的事情。
    （二）内联函数的编程风格
	关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。
	如下风格的函数Foo 不能成为内联函数：

		inline void Foo(int x, int y);
		// inline仅与函数声明放在一起
		void Foo(int x, int y) {}
	
	而如下风格的函数Foo则成为内联函数
		
		void Foo(int x, int y);
		inline void Foo(int x, int y) {}
		// inline与函数定义体放在一起

	所以说，C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。

	定义在类声明之中的成员函数将自动地成为内联函数

		class A 
		{
			public: void Foo(int x, int y) {}
			// 自动地成为内联函数   
		}

	将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：

		// 头文件     
		class A     
		{     
			public: void Foo(int x, int y);    
		}     
		// 定义文件     
		inline void A::Foo(int x, int y){}   




	C++内联函数不宜使用情况介绍

	C++语言中的各种应用是一个非常高深的内容，其中的语法、特性、标准类库都是我们值得深入研究的内容。C++内联函数就是其中一个比较重要的内容。我们在这里总结了一下C++内联函数不宜使用的环境。

　　	内联能提高函数的执行效率，为什么不把所有的函数都定义成C++内联函数?如果所有的函数都是内联函数，还用得着“内联”这个关键字吗?内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

　　	以下情况不适合使用inline函数

　　	(1)如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。

　　	(2)如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联(这进一步说明了 inline 不应该出现在函数的声明中)。

	


	注意点：

	C++内联函数既能够去除函数调用所带来的效率负担又能够保留一般函数的优点。然而，内联函数并不是万能药，在一些情况下，它甚至能够降低程序的性能。因此在使用的时候应该慎重。

　　	1.我们先来看看内联函数给我们带来的好处：从一个用户的角度来看，C++内联函数看起来和普通函数一样，它可以有参数和返回值，也可以有自己的作用域，然而它却不会引入一般函数调用所带来的负担。另外，它可以比宏更安全更容易调试。

　　	当然有一点应该意识到，inline specifier仅仅是对编译器的建议，编译器有权利忽略这个建议。那么编译器是如何决定函数内联与否呢?一般情况下关键性因素包括函数体的大小，是否有局部对象被声明，函数的复杂性等等。

　　	2.那么如果一个函数被声明为inline但是却没有被内联将会发生什么呢?理论上，当编译器拒绝内联一个函数的时候，那个函数会像普通函数一样被对待，但是还会出现一些其他的问题。例如下面这段代码：

		// filename Time.h  
		#include  
		#include  

		using namespace std;  

		class Time  
		{  
			public: inline void Show()  
			{  
				for (int i = 0; i<10; i++)  
				cout<   
			}  
		};  

	因为成员函数Time::Show()包括一个局部变量和一个for循环，所以编译器一般拒绝inline，并且把它当作一个普通的成员函数。但是这个包含类声明的头文件会被单独的#include进各个独立的编译单元中：

		// filename f1.cpp  
		#include "Time.h"  
		void f1()  
		{  
			Time t1;  
			t1.Show();  
		}  
		// filename f2.cpp  
		#include "Time.h"  
		void f2()  
		{  
			Time t2;  
			t2.Show();  
		}  

	结果编译器为这个程序生成了两个相同成员函数的拷贝：

		void f1();  
		void f2();  
		int main()  
		{  
			f1();  
			f2();  
			return 0;  
		}  

	当程序被链接的时候，linker将会面对两个相同的Time::Show()拷贝，于是函数重定义的连接错误发生。但是老一些的C++实现对付这种情况的办法是通过把一个un-inlined函数当作static来处理。因此每一份函数拷贝仅仅在自己的编译单元中可见，这样链接错误就解决了，但是在程序中却会留下多份函数拷贝。在这种情况下，程序的性能不但没有提升，反而增加了编译和链接时间以及最终可执行体的大小。但是幸运的是，新的C++标准中关于un-inlined函数的说法已经改变。一个符合标准C++实现应该只生成一份函数拷贝。然而，要想所有的编译器都支持这一点可能还需要很长时间。

　　	另外关于C++内联函数还有两个更令人头疼的问题。第一个问题是该如何进行维护。一个函数开始的时候可能以内联的形式出现，但是随着系统的扩展，函数体可能要求添加额外的功能，结果内联函数就变得不太可能，因此需要把inline specifier去除以及把函数体放到一个单独的源文件中。另一个问题是当内联函数被应用在代码库的时候产生。当内联函数改变的时候，用户必须重新编译他们的代码以反映这种改变。然而对于一个非内联函数，用户仅仅需要重新链接就可以了。

　　	这里想要说的是，内联函数并不是一个增强性能的灵丹妙药。只有当函数非常短小的时候它才能得到我们想要的效果，但是如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大。最令人烦恼的还是当编译器拒绝内联的时候。在老的实现中，结果很不尽人意，虽然在新的实现中有很大的改善，但是仍然还是不那么完善的。一些编译器能够足够的聪明来指出哪些函数可以内联哪些不能，但是，大多数编译器就不那么聪明了，因此这就需要我们的经验来判断。如果C++内联函数不能增强行能，就避免使用它!



	总结：
	1、inline只是一个编译器建议，编译器不一定非要展开inline函数
		例如：
		inline 函数地址引用
		inline 在递归函数中使用
	
	2、inline必须用于函数定义，对于函数声明，inline不起作用
		例如：
		inline max(int, int);	// 没有inline作用
		
		只有 inline max(int a, int b) {
			.....
		}	才有用。

	3、inline定义的函数 和 宏定义一样，只在本地文件可见。所以建议Inline定义的函数放在头文件中

	4、gcc中的inline函数法则

		1. static inline --->编译器本地展开。

		2. inline--->本地展开，外地为Inline函数生成独立的汇编代码

		3. extern inline--->不会生成独立的汇编代码。

		特性1. 即使是通过指针应用或者是递归调用也不会让编译器为它生成汇编码，在这种时候对此函数的调用会被处理成一个外部引用

		特性2. extern inline的函数允许和外部函数重名，即在存在一个外部定义的全局库函数的情况下，再定义一个同名的extern inline函数也是合法的。

	extern inline的用处：

	在一个库函数的c文件内，定义一个普通版本的库函数foo：
	mylib.c:

	void foo() {   
           ...;
	}

	然后再在其头文件内，定义（注意不是声明！）一个实现相同的exterin inline的版本：
	mylib.h:

	extern inline foo() {   
             ...;
        }

	那么在别的文件要使用这个库函数的时候，只要include了mylib.h，在能内联展开的地方，编译器都会使用头文件内extern inline的版本来展开。

	而在无法展开的时候（函数指针引用等情况），编译器就会引用mylib.c中的那个独立编译的普通版本。

	即看起来似乎是个可以在外部被内联的函数一样，所以这应该是gcc的extern inline意义的由来。








六、宏定义中do{}while(0) 的作用

	1，空的宏定义避免warning:
		#define foo() do{}while(0)

	2，存在一个独立的block，可以用来进行变量定义，进行比较复杂的实现。

	3，如果出现在判断语句过后的宏，这样可以保证作为一个整体来是实现：
		#define foo(x) /
		action1(); /
		action2();

	在以下情况下：
		if(NULL == pPointer)
			foo();

	就会出现action1和action2不会同时被执行的情况，而这显然不是程序设计的目的。